'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/static-web-scholcomm/teaching-resources/','title':"Teaching Resources",'content':""});index.add({'id':1,'href':'/static-web-scholcomm/tutorials/github/','title':"GitHub for Static Web Publishing",'content':"This tutorial introduces GitHub as a free static website publishing platform. No installation of additional software is required, however, you will need a GitHub account. By the end of this tutorial, you will have your own version of an open textbook template available for further editing. This tutotial is estimated to take between 30 and 60 minutes to complete.\nPrerequisities\n A free GitHub account Familarity with basic Markdown and YAML syntax  Outline\n Scenario: OER Textbook Start with an Open Textbook Template Configure Textbook Customize Your Open Textbook Publish Your Open Textbook   Scenario: OER Textbook A faculty member in the social sciences wants to make an open textbook on quantitative methods. The textbook will teach basic data analysis with the R programming language. The faculty member is very knowledgable about R for statistical analysis, but less knowledgable about GitHub and web publishing.\nStart with an Open Textbook Template Rather than starting from scratch, we are going to reuse an existing project for our own purposes. GitHub is a platform for sharing and collaborating on projects that are stored as Git repositories. With GitHub, people can share their code projects publicly, license their code, publish packages, report bugs, request features, and troubleshoot software problems. Together, Git and GitHub enable people a free method of sharing and publishing their work online. We\u0026rsquo;ll be using GitHub features to create, build, and deploy an open textbook using a template that\u0026rsquo;s available on GitHub.\nFirst, log in to your GitHub account. We will copy and adapt an existing git repository on GitHub in order to make our open textbook. To do this, we will need to \u0026ldquo;fork\u0026rdquo; an existing repository. When you create a fork on GitHub, you create a copy of someone elses git repository on your GitHub account in order create your own version of the project.\n Visit this repository: https://github.com/chrisdaaz/minibookdown Click on the Code tab in the repository view Click on the Fork button near the top of the page    Fork the Repository   The minibookdown repository contains the code we will need to begin creating your own open textbook. You should now have a repository under your account at a web address that looks like this: https://github.com/YOUR_USERNAME/minibookdown\nConfigure Textbook The textbook template comes with a workflow file that generates the output files for the book (i.e. the HTML, PDF, and EPUB versions). We\u0026rsquo;ll need to enable the workflow file in GitHub:\n  Enable Workflows in GitHub ActionsClick on the Actions tab\n   Click on the I understand my workflows, go ahead and enable them button  Customize Your Open Textbook The minibookdown repository we forked to your GitHub account contains the bare minimum of a Bookdown project. Bookdown is a popular open source tool for writing and publishing technical and scientific books from R Markdown files. We don\u0026rsquo;t need to know anything about the R programming language or statistical computing to use Bookdown for formating and publishing open textbooks. Bookdown will generate PDF, HTML, EPUB, and Word document versions of our open textbook for us.\nGitHub, in addition to being a host for source code files, is also a basic file editing system.\n  Open the index.Rmd file in the web editorFrom the main page of your repository, click on the index.Rmd file.\n    Edit the index.Rmd fileTo edit the file, click on the pencil icon near the right side of the page\n   Edit these lines with the working title and author of your textbook (make sure that the title and authors are in double quotations):  title:\u0026#34;A Mini Bookdown\u0026#34;author:\u0026#34;Your Name\u0026#34;Once you\u0026rsquo;re ready to save your changes, scroll down to the Commit changes button. This is also an opportunity to explain the reasoning behing the change. By default, GitHub fills the web form with Update FILENAME but you can change it to something more descriptive, like Adds book metadata. Make sure that the Commit directly to the main branch is selected and click on the Commit changes button  To add chapters, you can create more .Rmd files to your repository:\n  Add new fileFrom the main page of your repository (https://github.com/YOUR_USERNAME/minibookdown), click on the Add file button and select Create new file\n  Set the file name. The name needs to begin with two numbers to represent the chapter number, followed by a hyphen (-), the chapter title, and the R Markdown file extention (.Rmd). For example: 01-introduction.Rmd The first line of the file should start with a hash symbol # to represent the title of the chapter. Enter any title following a hash symbol (for example: # Introduction). The contents of the chapter can be written using Markdown syntax.  You can follow in the instructions in the Bookdown manual to continue adding and editing the contents of your open textbook.\nPublish Your Open Textbook By enabling workflow files in our repository, we\u0026rsquo;ve effectively programmed GitHub to build the HTML, PDF, and EPUB files for our textbook each time we update a file in our project directory. This setting is controlled by the .github/workflows/main.yml file on our repository.\nEach time we commit a change to one of the files, the book will re-build. This particular book takes a few minutes for changes to be made because GitHub spins up a new server, downloads our files, installs R, Pandoc, and LaTeX, runs scripts to build the output files, then moves the output files to a new branch called gh-pages. The gh-pages branch serves as a pseudo-server; is where the HTML, epub, and PDF files for our textbook are stored for public online access. This is through the GitHub Pages hosting service for static websites.\n  gh-pages branchThese are the static website files publicly available online.\n  Before we can view the web version of our textbook, we have to turn on the GitHub Pages feature.\n  Enable GitHub Pages in Repository SettingsClick on the Settings tab\n   Scroll down to the GitHub Pages heading In the Source section, click on the drop-down menu and change None to gh-pages + /(root} Click the Save button  You now have a publicly available open textbook on GitHub. You can view it by going to https://your-github-username.github.io/minibookdown/.\n"});index.add({'id':2,'href':'/static-web-scholcomm/tutorials/static-site-generators/','title':"Introduction to Static Site Generators",'content':"This tutorial will teach you the basics of using a static site generator. We will be using Hugo to build our demonstration site. We\u0026rsquo;ll play the role of a scholarly communications librarian. We\u0026rsquo;ll be using a command line terminal to install software and run commands and a text editor to edit and save plain text files. This in-depth tutotial is estimated to take between three and four hours to complete.\nWhile we will be using Hugo as our static site generator, this tutorial is not intended to be a cover the depth and breadth of Hugo. For that, I refer you to the Hugo documentation and community. Rather, this tutorial is about using static site generators in a library-publishing context.\nOutline:\n Scenario: Conference Proceedings  Local IT Constraints Static Websites   Plain Text vs Rich Text  Plain Text and Static Site Generators   Setting Up Your Computer  Plain Text Editors The Command Line Interface Installing Hugo Files and Folders   Working with a Static Site Generator: Hugo  Build and Preview Your Website Configuration Contents Templates   Appendix I: Tips for Publishing Static Websites to the Web  GitHub Pages Netlify   Appendix II: Tips for Archiving Static Websites   Scenario: Conference Proceedings There\u0026rsquo;s an academic department that is hosting a conference on campus. You approach them about depositing conference presentation materials in the institutional repository. The conference will feature research papers, posters, and a data visualization contest. The conference organizers are unimpressed by the look and feel of the institutional repository. They\u0026rsquo;re worried that the conference material will get \u0026ldquo;buried\u0026rdquo; among the other types of content in the repository. They want their web presence to look like a professional publication with a custom web address. They also want the text of the papers to display on the page in addition to PDF downloads.\nLocal IT Constraints Institutional repositories can be useful systems for storing and providing long-term public access to documents. They provide obvious benefits to libraries, but faculty and students might struggle to see those benefits. Unfortunately, the complexity of repository systems make them difficult or prohibitively costly to customize for specific collections or content types. It\u0026rsquo;s also generally not a good idea to customize repository systems for edge cases.\nCreating a separate website with platforms like WordPress or Drupal can be costly in terms of maintainance (and eventual content migration). We want to avoid unscheduled downtime and urgent security patches. In addition to requiring someone to manage the website contents, someone else (usually an IT administrator or vendor) needs to set up a server with application software and a database. Overtime, the server will need \u0026ndash; at a minimum \u0026ndash; software patches to secure the database and user credentials. You can\u0026rsquo;t afford to pay a vendor for hosted solution and you can\u0026rsquo;t get the commitments from IT managers to help you spin up and maintain a new web service.\nStatic Websites Static websites can provide custom presentation features for collections stored in a repository. They can be a supplemental publishing layer for a digital repository system without the maintenance overhead of traditional websites. Without a database or cloud-based application software, the security and maintance costs are avoided. We can think about static websites as an additional layer of publishing services to our patrons:\n Digital Repositories: Institutional storage layer Static Websites: Collection-level presentation layer  Recommended Reading: Becker, Devin, Evan Williamson, and Olivia Wikle. 2020. “CollectionBuilder-CONTENTdm: Developing a Static Web ‘Skin’ for CONTENTdm-Based Digital Collections.” The Code4Lib Journal, no. 49 (August).\n This article discusses the University of Idaho Library\u0026rsquo;s use of static websites as collection-level presentation layers for their CONTENTdm digital collections system.   Static websites are good options for stable content that doesn\u0026rsquo;t need continuous, on-the-fly updates. They\u0026rsquo;re a great solution for publications that are fixed in time (e.g. academic monograph), updated annually (e.g. open textbook), or semi-annually (e.g. academic journal). Considering the importance of web technologies to open access publishing, site site generators present a good opportunity for scholarly communications librarians to learn about web standards and best practices.\nIn this tutorial, we will make a conference proceedings website that links to content stored a repository. Together, the website and the repository will provide stakeholders with a full-featured, preservation-ready scholarly web publication.\nAlthough we will be using Hugo to build our website, our goals can be achieved using any static site generator. While other static site generators are designed with blogs, technical documentation, and e-commerse in mind, Hugo is a general-purpose website building tool with cross-platform compatibility. It has a growing user community and can easily scale to support websites with thousands of pages, which is partly why it\u0026rsquo;s the basis for some book publishing tools.\nPlain Text vs Rich Text There are two main types of documents we use to write and edit text: plain-text and rich text. Plain text exposes the raw, semantic characters within a document, whereas rich text displays the formatting features and styles.\n   File Contents File Extension Editors     Plain text .xml, .html, .md Notepad, TextEdit, VS Code   Rich text .docx, .rtf, .odt Microsoft Word, Scrivener    Most of us are trained to use rich text editors: emails, word documents, content management systems. This is for good reason: they\u0026rsquo;re easy to use and we need them for everyday things. For scholarly communications purposes, plain text offers some advantages over rich text, as Tenen and Wythoff (2014) explain:\n Plain text both ensures transparency and answers the standards of long-term preservation. MS Word may go the way of Word Perfect in the future, but plain text will always remain easy to read, catalog, mine, and transform. Furthermore, plain text enables easy and powerful versioning of the document, which is useful in collaboration and organizing drafts. Your plain text files will be accessible on cell phones, tablets, or, perhaps, on a low-powered terminal in some remote library. Plain text is backwards compatible and future-proof. Whatever software or hardware comes along next, it will be able to understand your plain text files.\n Coming to a plain text editor from a word processing program (like Microsoft Word), might feel like writing computer code rather than text for humans. That is because there is little material difference between plain text and code. Plain text is the format software developers use to write code. The only differences between code and text is the content and file extension. Plain text editors are not exclusive to writing code or reading data; people can write fiction in plain text (and some do).\nPlain Text and Static Site Generators Static site generators use plain text in order to separate content from styles. Static site generators use Markdown as the plain text markup language to express semantic formatting, such as headings, paragraphs, links, lists, and references, and YAML for metadata, such as title, author, abstract, date.\nContent Markdown uses a syntax that prioritizes human readability without sacrificing semantic structure. There are numerous tools available that will convert markdown to other formats, such as .html, .docx, .pdf, .tex, .epub, .jats, .tei, etc. The most popular markdown conversion tool is Pandoc.\nStatic site generators all have markdown processors to generate .html. Below is a comparison between the markdown input and the HTML output that static site generators make. Click “HTML Output” in each example to see the HTML output.\nMarkdown input: Headings\n# Site Title (Heading 1) ## Page Title (Heading 2) ### Section Heading (Heading 3) #### Subsection Heading (Heading 4)  HTML Output ↕  Site Title (Heading 1) Page Title (Heading 2) Section Heading (Heading 3) Subsection Heading (Heading 4)   Basic Emphasis with Bold and Italics\nThis is **bold**. This is _italics_.  HTML Output ↕  This is bold.\nThis is italics.\n  Markdown input: Links and Images\nThis is [a link](https://example.com) This is an Image: ![Protein translation by Bensaccount. CC BY 3.0 via Wikimedia Commons](https://upload.wikimedia.org/wikipedia/commons/9/94/Protein_translation.gif)  HTML Output ↕  This is a link\nThis is an Image:\n  Markdown input: Two Paragraphs and a Footnote with a link\nBounding ahead in panic surged hundreds of animals of a strange species. Shaped like deer, they had no antlers and their delicate bodies were covered with rich greenish-gold feathers. Eyes large with terror, feathers ruffled, they stampeded through the entrance of a corral that was so well camouflaged it was almost invisible in the tangled plants and tree trunks.[^1] In a corner of the corral, shadowed from the late afternoon sun, a tall, bare-chested young man waited motionless as an ironwood tree, watching the animals stream toward him. His only clothing was a pair of faded khaki shorts and soft leather boots. [^1]: Excerpt from [_Space Bat_ by Carl Selwyn](https://www.gutenberg.org/ebooks/63808), courtesy of Project Gutenberg.  HTML Output ↕  Bounding ahead in panic surged hundreds of animals of a strange species. Shaped like deer, they had no antlers and their delicate bodies were covered with rich greenish-gold feathers. Eyes large with terror, feathers ruffled, they stampeded through the entrance of a corral that was so well camouflaged it was almost invisible in the tangled plants and tree trunks.1\nIn a corner of the corral, shadowed from the late afternoon sun, a tall, bare-chested young man waited motionless as an ironwood tree, watching the animals stream toward him. His only clothing was a pair of faded khaki shorts and soft leather boots.\n  Paragraph excerpt from Space Bat by Carl Selwyn, courtesy of Project Gutenberg. \u0026#x21a9;\u0026#xfe0e;\n     There are many markdown tutorials and guides available online.\nMetadata Document metadata is embedded within markdown documents with YAML front-matter. The YAML metadata block always appears at the top of the file preceeded and followed by three hyphens ---. YAML is a plain text syntax for representing data as key-value pairs. MARC, DublinCore, and RDF are library examples of key-value pairs for bibiliographic metadata.\nYAML front-matter example for an article:\n--- title: Using Static Site Generators for Scholarly Publications and Open Educational Resources author: Chris Diaz date: 2018-11-08 journal: Code4lib Journal issue: 42 abstract: Libraries that publish scholarly journals, conference proceedings, or open educational resources can use static site generators in their digital publishing workflows. Northwestern University Libraries is using Jekyll and Bookdown, two open source static site generators, for its digital publishing service. This article discusses motivations for experimenting with static site generators and walks through the process for using these technologies for two publications. --- YAML syntax is strict; invalid YAML will break your website. There are a lot of online YAML validation tools you can use if you ever see an error you don\u0026rsquo;t understand.\nOne common issue with writing YAML is dealing with punctuation. If any of your YAML values include punctuation, put the entire value in single quotes ('') or double quotes (\u0026quot;\u0026quot;). If the value includes double quotes, wrap the value in single quotes (and vice versa). This will make it explicit to the static site generator that the value is a string (usually, YAML parsers can make this determination, but the quotes will make it explicit). For example:\nThis will break your website:\ntitle: Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb This is valid way to store the value:\ntitle: \u0026quot;Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb\u0026quot; Setting Up Your Computer If you\u0026rsquo;re interested, this is an excellent self-guided workshop to anyone interested in refreshing their knowledge on web fundamentals (i.e. HTML, CSS, JavaScript):\nWilliamson, Evan. 2019. “Web Crash Course! An Intro to Basic Web Concepts Using GitHub and GitHub Pages.” Web-Crash-Course. 2019.\n Plain Text Editors There are a lot of text editors we can use to build static websites. Every operating system includes a default plain text editor. Notepad is the default text editor on Windows machines; TextEdit is the default text editor on macOS. Either can be used to write and edit markdown and YAML.\nSelecting a text editor is a matter of personal preference. Most modern text editors can be customized with plugins, themes, and extensions to streamline the workflow and comfort of writing plain text. Syntax highlighting and validation are especially helpful. I recommend Visual Studio Code (VS Code). It\u0026rsquo;s free and open source with good documentation and a lot of helpful extensions for writing markdown and using static site generators. For this this tutorial (and working with the Hugo static site generator in the future), I recommend installing the Hugo Language and Syntax Support extension.\nThe Command Line Interface Static site generators are command line programs that you can run from a computer terminal. Depending on your system, the default program for your terminal interface might be called Command Prompt if you\u0026rsquo;re on Windows or Terminal if you\u0026rsquo;re on macOS. There are many terminal programs available and they each give you direct access to files and folders on your system.\nHere\u0026rsquo;s how to open your default computer terminal program:\nWindows   Click on the Start button Type cmd select the search result for the Command Prompt program  This will open your terminal to your User\u0026rsquo;s home directory. Here are three important commands to help you navigate your system:\n   Command Explanation     dir List the contents of your current directory   mkdir Make a new directory (or folder) called new-folder by running mkdir new-folder   cd Change directories to a target folder by running cd path\\to\\new-folder     macOS   Find the Terminal program by looking in the Utilities folder on your computer  This will open your terminal to your User\u0026rsquo;s home directory. Here are three important commands to help you navigate your system:\n   Command Explanation     ls List the contents of your current directory   mkdir Make a new directory (or folder) called new-folder by running mkdir new-folder   cd Change directories to a target folder by running cd path\\to\\new-folder     Linux   Find the Terminal program by looking in the Applications folder on your computer  This will open your terminal to your User\u0026rsquo;s home directory. Here are three important commands to help you navigate your system:\n   Command Explanation     ls List the contents of your current directory   mkdir Make a new directory (or folder) called new-folder by running mkdir new-folder   cd Change directories to a target folder by running cd path\\to\\new-folder      Installing Hugo Windows  You will need administrator priviledges on your machine to install and configure Hugo. Here\u0026rsquo;s a helpful video on installing Hugo on Windows.\nSetting Up Required Software Files and Folders  Open Windows Explorer Create a new folder at the root of your C Drive and call it Hugo: C:\\Hugo Create a subfolder in the Hugo folder called bin: C:\\Hugo\\bin  Download the latest .zip file for the Windows operating system from the Hugo Releases page. It will be a file that looks something like: hugo_x.xx.x_Windows-xxbit.zip. Here\u0026rsquo;s how to check if your running a 32-bit or 64-bit version of Windows.  Extract all of the contents of the .zip folder to the C:\\Hugo\\bin folder you already created.  Making hugo available as a command in your terminal Click on the Start button. Type Environment Variables and select the search result for Edit the system Environment Variables from the Control panel Click on the Environment Variables button In the System variables section, find the row that starts with PATH (PATH will be all caps). Double-click on PATH. Click the New button. Type in the folder path in which the hugo.exe was saved: C:\\Hugo\\bin. The PATH entry should be the folder where Hugo lives. Press OK when you’re done typing. Click OK at every window to exit.  Verify the installation Open the Command Prompt Type in hugo version and press Enter  If the installation is successful, the output will display the version of Hugo you\u0026rsquo;ve installed. If this doen\u0026rsquo;t happen, then verify that the folder location of the hugo.exe file has been added to your PATH Environmental Variables in your Advanced System Settings (see: above).     macOS  Here\u0026rsquo;s a helpful video on installing Hugo on macOS.\nThe easiest way to install Hugo on macOS (and lots of other open source software) is using the Homebrew package manager. Homebrew will download, install, update, and remove software packages with a few simple commands.\nInstall Homebrew The most up-to-date instructions will be available on the website, but here are the steps:\n Open a Terminal Copy this code and paste it into the terminal:  xcode-select --install  This will install Apple developer tools. You might get a message that this is already installed, and that\u0026rsquo;s OK. Once that\u0026rsquo;s done, copy and past this code into the terminal:  /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026quot;  This will install and set up Homebrew on your machine. You might be prompted to enter a password. This is the password you use to log into your machine.  Install Hugo  Now that you have Homebrew, you can install Hugo by running this code in your Terminal: brew install hugo  Verify Installation   After installing Hugo, run this code in your terminal: hugo version\n  If the installation is successful, the output will display the version of Hugo you\u0026rsquo;ve installed.\n   Linux  The easiest way to install Hugo on Linux (and lots of other open source software) is using the Homebrew package manager. There\u0026rsquo;s good change that hugo is available in your distributions default package manager, but Homebrew tends to have the most recent Hugo releases. Homebrew will download, install, update, and remove software packages with a few simple commands.\nInstall Homebrew The most up-to-date instructions will be available on the website, but here are the steps:\n Open a Terminal Copy this code and paste it into the terminal:  /bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026quot;  This will install and set up Homebrew on your machine.  Install Hugo  Now that you have Homebrew, you can install Hugo by running this code in your Terminal: brew install hugo  Verify Installation   After installing Hugo, run this code in your terminal: hugo version\n  If the installation is successful, the output will display the version of Hugo you\u0026rsquo;ve installed.\n    Files and Folders Files and folders account for the materiality of static websites before and after they are built. Traditional websites, on the other hand, are databases and servers that dynamically responds to requests from a content management system or web browser.\nStatic site generators do not use content management systems. They don\u0026rsquo;t have a graphical user interface and they don\u0026rsquo;t need a database. As far as we\u0026rsquo;re concerned, they\u0026rsquo;re a command we execute in a terminal that performs a transformation on a set of files and folders.\nThe files and folders we use to build the website are diffent than the files and folders we use to publish the website. Most of our editing and management of the site is within a working directory of files and folders. Once we\u0026rsquo;re ready, we run a command in our terminal and the static site generator handles the tranformation between the our working directory of files and folders and our output directory of ready-to-publish website files.\nHere\u0026rsquo;s a comparison between the files and folders for a basic hugo project, before and after transformation (the default output directory in a Hugo project is called public):\nClick to expand: Working Directory Containing Hugo Project Files ↕  conference-proceedings/ ├── config.yml ├── content │ ├── _index.md │ ├── papers │ │ ├── exactly.md │ │ ├── _index.md │ │ └── solutionize.md │ └── posters │ ├── _index.md │ ├── parking-lot.md │ └── same-or-better.md ├── layouts │ ├── 404.html │ ├── _default │ │ ├── baseof.html │ │ ├── list.html │ │ ├── single.html │ │ └── taxonomy.html │ ├── index.html │ └── partials │ ├── footer.html │ ├── menu.html │ ├── metadata.html │ ├── page-summary.html │ ├── pagination.html │ ├── poster.html │ └── toc.html ├── resources │ └── _gen │ ├── assets │ └── images └── static ├── css │ ├── bulma.css │ ├── bulma.min.css │ └── landing.css ├── images │ ├── Fig1.png │ ├── Fig2.png │ ├── Fig3.png │ ├── Fig4.png │ ├── Fig5.png │ ├── Fig6.png │ ├── Fig7.png │ └── Fig8.png └── js ├── bulma.js ├── clipboard.js ├── clip.js ├── lazysizes.min.js ├── menu.js └── smoothscroll.js 14 directories, 38 files    We use the working directory to store and edit our project files. Once we\u0026rsquo;re finished, we run the hugo command from our terminal.\nClick to expand: Output Directory Containing Final Website Files ↕  public/ ├── 404.html ├── categories │ ├── index.html │ ├── index.xml │ └── page │ └── 1 │ └── index.html ├── css │ ├── bulma.css │ ├── bulma.min.css │ └── landing.css ├── images │ ├── Fig1.png │ ├── Fig2.png │ ├── Fig3.png │ ├── Fig4.png │ ├── Fig5.png │ ├── Fig6.png │ ├── Fig7.png │ └── Fig8.png ├── index.html ├── index.xml ├── js │ ├── bulma.js │ ├── clipboard.js │ ├── clip.js │ ├── lazysizes.min.js │ ├── menu.js │ └── smoothscroll.js ├── papers │ ├── exactly │ │ └── index.html │ ├── index.html │ ├── index.xml │ ├── page │ │ └── 1 │ │ └── index.html │ └── solutionize │ └── index.html ├── posters │ ├── index.html │ ├── index.xml │ ├── page │ │ └── 1 │ │ └── index.html │ ├── parking-lot │ │ └── index.html │ └── same-or-better │ └── index.html ├── sitemap.xml └── tags ├── index.html ├── index.xml └── page └── 1 └── index.html 19 directories, 37 files    This creates a new directory called public containing our website files. These are the files we copy over to a web host to make our website available online.\nWorking with a Static Site Generator: Hugo Build and Preview Your Website Task: Download the exercise files from GitHub. You can download the zip file and extract them to a directory you can easily access on your machine, such as your \u0026ldquo;Documents\u0026rdquo; folder.  The exercise files contain the working directory for a Hugo project. The Hugo software not only provides a process for building websites, it also provides a local web server we can use to preview our websites before we build the final versions. After following these steps, you should be able to build and preview a functional website on your computer with Hugo.\n Open the Folder for the exercise files in VS Code: File \u0026gt; Open folder...; you should see the contents of the static-web-scholcomm-exercise-files folder in the left sidebar of VS Code Open a Terminal in VS Code: Title menu \u0026gt; Terminal \u0026gt; New Terminal Start the Hugo server to preview the website by entering this command into the terminal: hugo server Open a web browser and visit: http://localhost:1313  You should now see a website template for the conference proceedings we\u0026rsquo;re going to make. If you see a website, this means that Hugo is installed on your computer and the files are rendering properly on your machine. While you work with static site generators, it\u0026rsquo;s always nice to have the option to preview your updates locally before pushing changes to a server. With the Hugo server running, any changes to working directory files with automatically trigger a rebuild of the site for you to preview in a web browser.\n If you got an error running the hugo server command, there might have been a problem installing Hugo and adding the hugo.exe file to your PATH variable. Re-try the installation steps. If that doesn\u0026rsquo;t work, search the web for error messages to troubleshoot the issue. There\u0026rsquo;s always a good chance someone else has run into the same problem!\n The exercise files contain the starter files for a basic Hugo project. The folders are organized in a way that separates content from layouts and styles.\nMost people who use static site generators create and edit the Markdown files in the content folder (/content/) and edit the settings in the configuration file (config.yml). The Markdown files in the /content/ folder contain all of the text of the website, whereas the configurations in the config.yml contain site-wide settings, such as the website title.Each theme you use will have it\u0026rsquo;s own configutation settings in the config.yml file (good themes document what each setting is for!). The other folders in the working directory are used for more advanced features and customizations. For example, the layouts and styles are usually set by a theme. Themes are usually developed for a specific use case (e.g. blog, portfolios, documentation, e-commerce) with features (e.g. search, image galleries, CSS framework support).\nThe most popular static site generators have numerous themes available for people to use and customize in their websites. The Hugo community has published a lot of themes for anyone to use with their websites. In this tutorial, we\u0026rsquo;ll be using a simplified version of the Hugo Bulma theme and the Bulma CSS framework.\nConfiguration The first file we\u0026rsquo;ll edit is the configuration file: config.yml. Hugo allows you to write your configuration files in YAML, JSON, or TOML. Each of these languages have slightly different syntaxes, but they both perform the same functions: storing site-wide settings.\nTask: Open the config.yml in a text editor, change the title, description, institution, and publisher for the conference to the following values:     Attribute Value     title Proceedings of the Society of Workplace Jargon   description Presentations from the annual conference of the Society for Workplace Jargon   institution University College   publisher University College Library Press    When you\u0026rsquo;re done, save the file (Ctrl S). You can check out the changes in a web browser. If your local server is still running and the browser is already open to http://localhost:1313, the changes should already be there. If not:\n Open a Terminal in VS Code: Title menu \u0026gt; Terminal \u0026gt; New Terminal Start the Hugo server to preview the website: hugo server Open a web browser and visit: http://localhost:1313  For more information, see: Hugo Documentation: Configuration\nContents Task: Create the Data Visualizations section of the website by adding a new section to the website.   Find two (or more) public domain or Creative Commons licensed images of data visualizations in Wikimedia Commons. With the Advanced Search, you can fiter by file type to return only images. Keep them open as tabs in your browser. Create a folder called visualizations as a subfolder of /content/ Create one Markdown file (.md) for each visualization you plan to include and add the file to the visualizations subfolder Copy and paste this YAML metadata block at the top of each Markdown file:  --- title: authors: [\u0026quot;first_name last_name\u0026quot;, \u0026quot;first_name last_name\u0026quot;, \u0026quot;first_name last_name\u0026quot;] date: abstract: image_src: image_alt: # License options are: by, by-nc, by-nc-nd, by-nc-sa, by-nd, by-nd-nc, by-sa, public domain # See Creative Commons website for more info: https://creativecommons.org license: --- Add in values for each of the metadata fields within the YAML metadata block. See below for instructions on how to format the values for each field.  Here\u0026rsquo;s a mapping of Wikimedia image metadata and metadata we\u0026rsquo;re using on the site:\n   Wikimedia Website     title File name   authors Creator. Make sure that all creators are listed within brackets and quotations, separated by commas if there are more than one. For example, a single creator would look like [\u0026quot;first_name last_name\u0026quot;] whereas multiple creators would look like [\u0026quot;first_name last_name\u0026quot;, \u0026quot;first_name last_name\u0026quot;, \u0026quot;first_name last_name\u0026quot;]. Organization names, such as NASA/JPL/Cornell University just need to be separated by commas, e.g. [\u0026quot;organization name\u0026quot;, \u0026quot;organization name\u0026quot;]   date Date   abstract Description   license See: Creative Commons for options    For the image_src value, you\u0026rsquo;ll need to find the URL for the image to paste into that field.\nClick on \u0026ldquo;Use this File on the Web\u0026rdquo; Copy the File URL (for example, https://upload.wikimedia.org/wikipedia/commons/x/xx/FileName.png) Paste the File URL in the image_src field Write alternative text for the image in the image_alt field. If you\u0026rsquo;re interested, here\u0026rsquo;s guidance on writing alt tags for complex images, like data visualizations.  When you\u0026rsquo;re done, you should have two new markdown (.md) files in a new visualizations folder, which itself is a subfolder of the content folder. The exercise files already include a template for rendering the visualizations (in /layouts/_default/single.html). If you need to, use the markdown files within the /papers/ and /posters/ folders as a reference while you build out the visualizations section of the site.\nWhen you\u0026rsquo;re done creating the markdown (.md) files for the visualizations, you can test to see that everything is working properly by running the hugo server command in a terminal and opening a web browser to http://localhost:1313/visualizations/. Make sure that your terminal open to the static-web-scholcomm-exercise-files directory for the hugo command to work. If your terminal is busy from a previous process, you can stop it by entering Ctrl+C in the terminal and restarting the server by entering hugo server in the terminal.\nTemplates Templates determine the structure and layout of web pages. In the exersice files, the templates are .html files within the layouts folder. Templates are an advanced topic with any static site generator. Not only do you need some basic familiarity with HTML and CSS, you\u0026rsquo;ll also need to learn the basics of whichever templating language the static site generator uses. However, this is a skill that pays off because it provides a new layer of control over your digital publications, opening up new pathways to work with more dynamic content.\nBibliographic metadata is probably the first reason to customize templates. Static site generators can support pretty much any semantic web metadata standard you can think of, but you\u0026rsquo;ll probably have to be the one to implement it since most themes have that template available.\nBut first, let\u0026rsquo;s start with the basic templating syntax in Hugo. Hugo is written in the Go programming language and uses the Go Template package. We don\u0026rsquo;t need to know anything about Go to starting making and editing templates, though.\nAs mentioned before, most of our site contents are expressed as either Markdown or YAML. These are the data that get fed into HTML templates when Hugo builds the site. The template files are in the layouts folder of our project (or in the layouts directory of a theme). Here\u0026rsquo;s a snippet of HTML code from /layouts/_default/baseof.html:\n\u0026lt;title\u0026gt;{{ .Title }} | {{ .Site.Title }}\u0026lt;/title\u0026gt; This is the \u0026lt;title\u0026gt; HTML tag that is required for any web page. Within the opening and closing brackets, there are two placeholders: the title of the page and the title of the site. Each placeholder represents a variable.\n  The first placeholder {{ .Title }} is a page variable. This value will change for every page in the website. In Hugo, .Title always refers to the title of the page, which is usually defined in the page\u0026rsquo;s YAML front-matter.\n  The second placeholder {{ .Site.Title }} is a site variable. This value will not change for every page; it\u0026rsquo;s the same across the entire website. The value is defined in the title field of the config.yml file.\n  Let\u0026rsquo;s say that we\u0026rsquo;re on the Home page, and the website title is Conference Proceedings, the \u0026lt;title\u0026gt; on the website will render this:\n\u0026lt;title\u0026gt;Home | Conference Proceedings\u0026lt;/title\u0026gt; Here\u0026rsquo;s a helpful video on templating basics in Hugo.\nWith templates, we can pull in any YAML or Markdown we need, wherever in our site we need them. Let\u0026rsquo;s give this a try by by adding Google Scholar metadata tags to our conference proceedings.\nGoogle Scholar Task: Add Google Scholar \u0026lt;meta\u0026gt; tags to the \u0026lt;head\u0026gt; element of our HTML markup.  According to Google Scholar Indexing guidelines, the crawlers look for \u0026lt;meta\u0026gt; HTML tags containing Highwire Press tags, for example:\n\u0026lt;meta name=\u0026quot;citation_title\u0026quot; content=\u0026quot;The testis isoform of the phosphorylase kinase catalytic subunit (PhK-T) plays a critical role in regulation of glycogen mobilization in developing lung\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_author\u0026quot; content=\u0026quot;Liu, Li\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_author\u0026quot; content=\u0026quot;Rannels, Stephen R.\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_author\u0026quot; content=\u0026quot;Falconieri, Mary\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_author\u0026quot; content=\u0026quot;Phillips, Karen S.\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_author\u0026quot; content=\u0026quot;Wolpert, Ellen B.\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_author\u0026quot; content=\u0026quot;Weaver, Timothy E.\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_publication_date\u0026quot; content=\u0026quot;1996/05/17\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;citation_pdf_url\u0026quot; content=\u0026quot;http://www.example.com/content/271/20/11761.full.pdf\u0026quot;\u0026gt;  Create a new file in /layouts/partials/ called gs-metadata.html Copy the following code and paste it into the gs-metadata.html file  \u0026lt;meta name=\u0026quot;citation_title\u0026quot; content=\u0026quot;{{ .Title }}\u0026quot;\u0026gt;{{ range .Params.authors }} \u0026lt;meta name=\u0026quot;citation_author\u0026quot; content=\u0026quot;{{ . }}\u0026quot;\u0026gt;{{ end }}{{ with .Params.doi }} \u0026lt;meta name=\u0026quot;citation_publication_doi\u0026quot; content=\u0026quot;{{ .Params.doi }}\u0026quot;\u0026gt;{{ end }} \u0026lt;meta name=\u0026quot;citation_publication_date\u0026quot; content=\u0026quot;{{ .Params.date }}\u0026quot;\u0026gt;{{ with .Params.pdf }} \u0026lt;meta name=\u0026quot;citation_pdf_url\u0026quot; content=\u0026quot;{{ .Params.pdf }}\u0026quot;\u0026gt;{{ end }} Templates also allow you to loop over fields with multiple values and apply conditional logic. For example, the range function is used to iterate over a list of items, like authors. For each author, the template will create a new \u0026lt;meta\u0026gt; tag with the name=\u0026quot;citation_author\u0026quot; attribute until all authors have been added. The with function is similar to if statements in other programming languages. In this example, with checks to see if the page has defined a doi in the YAML front-matter. If so, then Hugo will create a \u0026lt;meta\u0026gt; tag with the name=citation_doi attribute. Hugo has an extensive list of functions for creating templates.\nOnce you\u0026rsquo;ve created the file and saved the site, test it by running hugo server in a terminal and opening https://localhost:1313 in a web browser. Because we are editing web page metadata, and not web page content, we can see the changes we are making by viewing the source of the web page in our browser. You can view the source of any web page by right-clicking the page in your web browser and selecting the View page source option. The Google Scholar metadata we are adding to our demo website will appear near the top of the page when you\u0026rsquo;re viewing the page source.\nThis concludes the introductory tutorial on static site generators with Hugo. Congrats! The following sections are intended to provide guidance on publishing and archiving static websites in a real-world contexts.  Looking for more training and exercises? Check out the Getting Started with Static Website Generators workshop by Kaitlin Newson and Kim Pham from the Code4Lib 2018 conference.  Appendix I: Tips for Publishing Static Websites to the Web Static site generators can build your website to a local or production server environment.\n  Local Environtment: This is sometimes called a development environment. When we\u0026rsquo;ve been previewing our site with the hugo server command, we\u0026rsquo;ve been using the local environment. With this environment, the hugo server command turns our machines into mini web servers that host and deliver the website in our web browsers at a localhost URL.\n  Production Environment: When we\u0026rsquo;re ready to deploy the website online, we need to use a different command for a production server environment. With Hugo, this command is simply hugo. The hugo command will create a new subfolder in your project called public that will contain all of the final HTML, CSS, JavaScipt, images, and other asset files (e.g. PDFs, datasets, etc.) you need to have a fully-functioning static website.\n  One of the primary differences between the hugo command and the hugo server command is how it handles URLs and permalinks. With hugo server, all of the URLs will be relative to a Base URL called https://localhost:1313 by default. The hugo command, however, will set all of your URLs and Permalinks according to whatver you set as the baseURL value in the config.yml file. The baseURL refers to the hostname and path address to your website. For example, if you purchased the https://example.com domain name for your website, this line would be in your config.yml file: baseURL: https://example.com. The baseURL can also be a subdomain (baseURL: https://conference.example.com) or a subdirectory of a website (baseURL: https://example.com/conference/).\nWhile deploying to a production server can get complicated, we don\u0026rsquo;t need to worry about the server meeting specific software or operating system requirements. We just need to be able to upload static file to it. Here are some popular static website hosting options and some tips on using them:\nGitHub Pages GitHub is a platform for hosting Git repositories containing source code for software packages. It\u0026rsquo;s popular website for finding open source projects communicating with users of specific pieces of software. GitHub Pages is a free static website hosting service offered to users of the GitHub platform.\nThe following steps will show you how to move your website files to GitHub and deployed publicly on GitHub Pages. This is intended to demonstrate the process of moving a locally developed static website online; this is not a recommend workflow for static site deployments (more on that below).  In your Hugo Project Files\n Open the config.yml file and add the valye for the baseURL field. Use https://YOURUSERNAME.github.io/conference-proceedings/ where YOURUSERNAME is replaced with your GitHub username Run: hugo to build your site to the public directory  In GitHub\nLogin to GitHub Create a New repository: Title menu + \u0026gt; New Repository Enter conference-proceedings in the Repository Name field Click on Create Repository; this will display many options to add files to the repository Click on the link that says: upload an existing file Upload all of the files within the public directory to the Github repository. It is important that the index.html file is at the root of your of repository. Do not upload the public folder itself; upload the files within the public folder Click on the Commit button. This will upload your website files, which might take a few moments. When the upload is complete, click on the Settings tab Scroll down to the GitHub Pages section In the Source drop-down menu, select main, make sure that /(root) path is selected, then click save. This will deploy your website to this URL: https://YOUR_USERNAME.github.io/conference-proceedings  This is all you need to do to manually deploy a website using the GitHub Pages service. Static site generators, like open source software in general, make heavy use of the Git version control software. What we just did was intended to demonstrate a manual deployment of a static website to a public web server. As a reference, here\u0026rsquo;s what a more common workflow would look like:\n Create your website\u0026rsquo;s project folder: hugo new site new-website-name Change directories into the website folder: cd new-website-name Initialize a Git repository: git init Create and edit your website locally (just as we did earlier in this tutorial) Upload your local Git repository to GitHub:  git remote add origin https://github.com/YOUR_USERNAME/new-website-name.git git branch -M main git push -u origin main Set up an automated deployment workflow that pushes a new build of your website to a server with every change to the git repository on GitHub.  By storing your source code in a GitHub-hosted repository, you can deploy static sites directly to GitHub Pages or third-party services like Netlify for free.\nThe Hugo Documentation includes a lot of hosting and deployment recommendations. Many of these options have free tiers, but static website hosting usually only costs a few dollars per month.\nNetlify Netlify is a web hosting company specializing in static websites. They provide free individual accounts, integration with GitHub, and numerous 1-click deployment options with popular static site generators. This is a typical workflow with Netlify:\n Set up a web project with static site generator on a personal computer Initialize a Git repository on the project Push a copy of the repository to GitHub Grant Netlify access to GitHub repositories Netlify copies the web project to their servers, build the website, and host the website Updates to web project get pushed to GitHub copy and automatically trigger new website deploys  Automating this workflow can take some time up front, it saves a lot of time over the course of updating the website. Netlify also provides Netlify Drop, which is an option to upload the pre-built website folder directlly (no Git/ GitHub integration necessary).\nFor deploying the conference proceedings website, run the hugo command and upload the /public/ folder to Netlify Drop to make the website available to the public.\nAppendix II: Tips for Archiving Static Websites Static websites themselves are not digital repository or preservation systems. They do, however, provide a few options for creating OAIS Submission Information Packages (SIPs). In fact, it\u0026rsquo;s possible that static websites are easier to archive than database-driven websites, as Rumianek (2013) writes:\n Archiving CMS based websites proves much more difficult, because there may exist different views on the content depending on the browser and/or permissions of each user. Recovering a CMS based website from an archive generated by a crawler is not possible either, since the content archived by the crawler is affected by the crawler\u0026rsquo;s permissions and configuration, and only a single view is archived. Therefore, the database itself is not recoverable.\n For static websites, there are two options: \u0026ldquo;downloading a copy of the files using a crawler, or, by getting a copy of the necessary folders containing all of the files from the site\u0026rsquo;s operator\u0026rdquo; (Rumianek 2013).\nWeb archiving tools like Archive-it can be set to crawl the public version of the website. This is a process where a machine visits the website and systemically creates copys of all of the files of the website. As the creator of a static website, you have more flexibility in creating an OAIS Submission Information Package (SIP):\n  Archiving the public website: Run the hugo command on your completed website, create a .zip file of the /public/ folder, and add it to a digital repository or digital preservation system.\n  Archiving the source material: Create a .zip file of the entire static site project folder, including the content, layouts, and assets files, and add it to a digital repository or digital preservation system.\n  "});index.add({'id':3,'href':'/static-web-scholcomm/tutorials/','title':"Tutorials",'content':""});index.add({'id':4,'href':'/static-web-scholcomm/teaching-resources/lesson-plan/','title':"Lesson Plan",'content':"This lesson plan provides an assortment of learning modules for teaching static web technologies for digital scholarship and scholarly communications librarianship. Each topic includes a learning objective and recommended readings, viewings, or tutorials for use in workshops or seminars.\n Download PDF   Download DOCX   Topics:\n Introduction  Benefits for Digital Scholarship Challenges and Drawbacks   Static vs Dynamic Websites Plain Text vs Rich Text Static Websites and Accessibility Static Websites in Context  Popular Static Site Generators Recommendations for Math   Open Infrastructure for Scholarly Communications  Community Engagement     Introduction Learning Objective: Participants will be able to recognize the strengths and limitations that static websites provide scholarly communications librarians.  Static websites can facilitate the distribution, access, and longevity of digital scholarship. A static website is simply a set of files that exist somewhere on a public web server. While they provide some benefits to librarians who facilitate the dissemination and preservation of the scholarly record, they \u0026ndash;by themselves\u0026ndash; are inadequate for satisfying the full range of scholarly communication technology needs.\nBenefits for Digital Scholarship   Static websites support a variety of digital scholarship and scholarly communications use cases, including scholarly monographs, academic journals, digital exhibits, reproducible research, open educational resources, data visualizations, and digital library projects.\n  Static websites are built on open source software and open web standards. There\u0026rsquo;s nothing proprietary to the underlying technologies.\n  Static websites can be hosted anywhere, enabling the freedom to deploy to (and migrate from) any hosting provider.\n  Static websites rely on fewer pieces of technical infrastructure than dynamic web platforms: no databases, no software updates, no server maintenance, no security patches\n  Static websites are cheaper to maintain and preserve than websites run on content management systems\n  Challenges and Drawbacks   Static websites are more difficult to learn because they don\u0026rsquo;t typically include a content management system. Instead, they require direct interaction plain text files via a text editor and command line interface. Static websites can be used with content management systems; however, this usually requires additional configuration.\n  They are more difficult to edit after the work is complete. For scholarly publications and digital scholarship projects, frequent editing and updating may not be a primary concern, but projects involving many content editors with on-the-fly content updates may be better served by a publishing platform with a content management system.\n  They do not support \u0026ldquo;logged in\u0026rdquo; user experiences. Static websites are easiest to make when they are public and read-only. Administrative dashboards, analytics, submission management systems, and subscriber content would need to be handled using other services.\n  This is not unique to static websites; however, by taking on more control over the semantic markup and styles by editing and developing templates, you assume more responsibility over the usability and accessibility of the website. Using \u0026ldquo;as-is,\u0026rdquo; warranty-free open source software requires an added level of care over the quality of the code. For example, one cannot assume that a popular open source theme for a static site generator meets your institutions digital accessibility policies. It\u0026rsquo;s your responsibility to test the website and make improvements accordingly.\n  Deciding to use a static website for a digital scholarship project requires a thorough understanding of the project\u0026rsquo;s use cases. For example, while static websites may be excellent options for digital exhibits and scholarly web publications, they are not suitable alternatives for repository systems or pre-print servers.\nReading: Newson, Kaitlin. 2017. “Tools and Workflows for Collaborating on Static Website Projects.” The Code4Lib Journal, no. 38 (October). .\nNewson introduces static site generators for digital library projects with a case study involving a digitized maps collection. Newsom explains how static site generators work and discusses their advantages and disadvantages for team projects.\n Static vs Dynamic Websites Learning Objective: After examining this topic, participants will be able to describe the differences between static and dynamic websites.  Most of the websites we use every day are dynamic websites. Dynamic websites store content in databases and use web servers to generate web pages upon each visit. Often, dynamic websites are managed by a content management system (CMS), like WordPress, Drupal, or Omeka. This make them attractive for websites that require permissions-based access, e-commerce, or social interactions. However, dynamic websites need continuing resources for software updates, maintenance, and security.\n Traditional (dynamic) website publishingContent stored in a database is processed by a web server in order to be displayed on the device (Image © 2020 The J. Paul Getty Trust)\n  Static websites do not use databases to store content or web servers to dynamically generate web pages; instead, the web pages are pre-built on a personal computer using a static site generator and stored as static HTML files on a public web server, thereby eliminating the need for database security and routine software updates for servers. This makes them cheaper to host and easier to maintain.\n Static-site publishingContent is generated on a computer and uploaded to web server in order to be displayed as-is on the user\u0026rsquo;s device (Image © 2020 The J. Paul Getty Trust)\n  Static websites used to make up the majority of the web in the 1990\u0026rsquo;s. People would write HTML code (i.e. \u0026ldquo;markup\u0026rdquo;) for every page and upload the files to a public web server. Today, people use static site generators to automate and simplify the process for making websites. \u0026ldquo;Think of a static site generator as a script which takes in data, content and templates, processes them, and outputs a folder full of all the resultant pages and assets\u0026rdquo; (Hawksworth, 2020). Compared to dynamic website platforms, static site generators are relatively small pieces of open source software we can run on our computers ourselves.\nTutorial:\nWilliamson, Evan. 2020. “Introduction to Creating Websites with GitHub Pages and Jekyll.” Go-Go Gh-Pages! This is an excellent introduction to using GitHub for static site publishing. From the website: \u0026ldquo;This workshop will introduce using free hosting from GitHub Pages integrated with the popular static website generator Jekyll. Along the way we will cover the basics of GitHub, HTML, Markdown, and Jekyll. You will learn how to set up a project repository, write content in Markdown, and publish your site, all using GitHub’s user friendly web interface. More advanced usage of Jekyll for local web development is introduced final section.\u0026rdquo; Follow along with the videos for the full workshop experience.\n Static websites have gained in popularity in the open source web development community with the rise of JAMstack. JAMstack is an architecture for building websites using static site generators (of which there are hundreds of open source options). JAMstack separates the front-end interface from the backend database in order to produce websites that are less vulnerable to software degredation and security risks. When publishing scholarly texts online, scholarly communications librarians rarely need backend database features. We primarily need the front-end to provide stable, unlimited online access to web publications.\n   Frontend Features Backend Features     Public HTML interface Server-rendered web pages   Metadata (JSON/HTML) Storing user credentials   Full-text PDF download Managing e-commerce transactions    Viewing: Watch at least first 6 minutes of \u0026ldquo;What is the JAMstack? and let\u0026rsquo;s BUILD one\u0026rdquo;\nFollow-up activity: Examine three publishing tools from the Catalogue in “Mind the Gap: A Landscape Analysis of Open Source Publishing Tools and Platforms” and make a case for why each tool is or is not an example of JAMstack in scholarly communications.\n Plain Text vs Rich Text Learning Objective: Produce and transform plain-text documents for editing, publishing, and archiving  Static site generators require content and styles to be stored as plain text. There are two main types of documents we use to write and edit text: plain-text and rich text. Most of us are trained to use rich text editors: emails, word documents, content management systems. This is for good reason: they\u0026rsquo;re easy to use and we need them for everyday things. Plain text exposes the raw, semantic characters within a document, whereas rich text displays the formatting features and styles. For librarians, plain text offers some advantages over rich text, as Tenen and Wythoff (2014) explain:\n Plain text both ensures transparency and answers the standards of long-term preservation. [Microsoft] Word may go the way of Word Perfect in the future, but plain text will always remain easy to read, catalog, mine, and transform. Furthermore, plain text enables easy and powerful versioning of the document, which is useful in collaboration and organizing drafts. Your plain text files will be accessible on cell phones, tablets, or, perhaps, on a low-powered terminal in some remote library. Plain text is backwards compatible and future-proof. Whatever software or hardware comes along next, it will be able to understand your plain text files.\n    File Contents File Extensions Editors     Plain text .xml, .html, .md Notepad, TextEdit, Visual Studio Code   Rich text .docx, .rtf, .odt Microsoft Word, Scrivener    Coming to a plain text editor from a word processing program (like Microsoft Word), might feel like writing computer code rather than text for humans. That is because there is little material difference between plain text and code. Plain text is the format software developers use to write code. The only differences between code and text is the content and file extension. Plain text editors are not exclusive to writing code or reading data; people can write fiction in plain text (and some do).\nReading: Gil, Alex. 2015. “The User, the Learner and the Machines We Make.” Minimal Computing: A Working Group of GO::DH. May 21, 2015. This is the canonical essay on minimal computing in digital humanities. Minimal computing centers around the question, \u0026ldquo;what do we need?\u0026rdquo; Scholarly communications librarians need resources for publishing academic texts online in order to be discovered and accessed by the public without restrictions. This can be accomplished with an open source static site generator, basic web hosting, and minimal maintenance costs. Importantly, the essay asks us to \u0026ldquo;displace [our] reliance on \u0026lsquo;user friendly\u0026rsquo; mechanisms,\u0026rdquo; like content management systems and hosted platforms, for smaller technical infrastructures, like plain-text and static websites, that are cheaper to sustain and easier to preserve.\nActivity:\n Read \u0026ldquo;Getting Started with Markdown\u0026rdquo; to learn the basic syntax Write a markdown version of your resume/CV in a text editor (such as Dillinger) Convert your resume/CV from markdown to HTML5 with Pandoc Save the HTML5 code to a file called resume-cv.html  Tutorials:\n  Tenen, Dennis, and Grant Wythoff. 2014. “Sustainable Authorship in Plain Text Using Pandoc and Markdown.” Programming Historian, March. I strongly recommend some familiarity with Pandoc for roles or projects involving digital publishing. It was developed with academic writing in mind and is usually a behind-the-scenes piece of software within many digital publishing tools. If you\u0026rsquo;d prefer not to install Pandoc on your machine, you can use the Try Pandoc online tool to convert between plain-text formats.\n  “Fundamentals: YAML \u0026amp; Markdown.” 2020. In Quire: Multiformat Book Publishing. J. Paul Getty Trust, Los Angeles. This is a chapter from the manual for Quire, a multiformat book publishing program, but it is an excellent introduction to the fundamentals of Markdown and YAML in the context of a static site generator for book publishing. The concepts covered in the chapter are essential to using any static site generator.\n   Static Websites and Accessibility Static site generators can be a good tool for learning about web accessibility. They give you full control over the HTML templates and CSS styles. Most of the time, the templates and styles are by a theme. Themes are separate components for static site generators that users make and publishing as open source projects. Whether you are using a theme or creating your templates from scratch, it is your responsibility to ensure that the resulting web publication can be used by everyone.\nFrom an authoring standpoint, plain text is a more accessible format than rich text. Seo and McCurry (2019) study the accessibility of authoring tools for scientific documents (i.e. documents that require math formulas, embedded graphics, figures, and bibiliographic citations) and introduce the Accessible RMarkdown Online Writer, a web-based authoring tool for blind and low-vision writers of scientific content. Markdown, as an accessible authoring format, is a semantically rich plain text format with a minimal syntax, support for LaTeX math, and wide range of output formats: HTML, PDF, Microsoft Word, RTF, EPUB, PowerPoint, etc.\nMarkdown is independent of static websites and static site generators. Markdown can be used in content management systems and dynamic website platforms, too. Regardless of your web technology stack, distributing multiple formats of your content to your audience, such as Markdown in addition to HTML or PDF, provides choice for people to access your work. With static site generators \u0026ndash;and web-hosted git repositories\u0026ndash; distributing the Markdown source of works is trivial.\nReadings:\n  “What Is Accessibility?” n.d. MDN Web Docs. Accessed December 3, 2020.\n  “HTML: A Good Basis for Accessibility.” n.d. MDN Web Docs. Accessed December 3, 2020.\n  Seo, Joo Young, and Sean McCurry. 2019. “LaTeX Is NOT Easy: Creating Accessible Scientific Documents with R Markdown.” Journal on Technology and Persons with Disabilities 7 (16).\n  Recommending Viewing: Initiative (WAI), W3C Web Accessibility. 2020. “Web Accessibility Perspectives: Explore the Impact and Benefits for Everyone.” Web Accessibility Initiative (WAI). December 3, 2020. https://www.w3.org/WAI/perspective-videos/.\nActivity\n Using Chrome Developer Tools, visit a website and perform an accessibility audit. With the same website, use WAVE to perform an accessibility audit. What were the differences between each tool\u0026rsquo;s evaluations?   Static Websites in Context Learning Objective: Recommend static site generators options to students and faculty in various disciplines.  Popular Static Site Generators All static site generators have a similar workflow: (1) install the software, (2) add your content, (3) run the build or serve command from your terminal, (4) upload the files to a server. That said, some static site generators are easier to use than others. In my experience with open source, the popularity of the tool correlates with its ease of use. Here\u0026rsquo;s a very incomplete overview of some popular static site generators.\nJekyll If modern static site generators were a band, Jekyll would be a founding member. It was designed as a blogging system for developers that grew into a more general-purpose website builder over time. For a while, it was the easiest static site generator to use on the GitHub Pages hosting service. This made it an obvious choice for scores of personal blogs, portfolios, documentation websites, and research projects.\nJekyll is written in Ruby. You don\u0026rsquo;t need to know anything about Ruby to use Jekyll, but you do need Ruby and Bundler, a Ruby package manager, installed on your computer in order to use it. This is a big hurdle for installing and using Jekyll on Windows (it can be done). Luckily, there are some resources available to help you make a Jekyll website without installing Jekyll on your computer (a more complete list can be found here).\n  Jekyll Now is a tutorial that teaches you how to create a blog \u0026ldquo;in 30 seconds\u0026rdquo; through the GitHub web interface. If you ever need a quick and easy place to host your CV or porfolio, Jekyll Now is probably the easiest option available.\n  Collection Builder is a Jekyll-based or GitHub-based workflow for creating digital collection and exhibit websites following collections as data principles. The GitHub Pages version can used without installing Jekyll on your machine. Websites with Collection Builder can be made with a spreadsheet of metadata, a folder of images, and a configuration file. Many of the digital collections from the University of Idaho were made with Collection Builder.\n  Wax is a Jekyll theme and digital production toolset for making digital exhibits with an interoperable IIIF image viewer. Wax requires Jekyll installed on your computer, but Wax provides everything necessary for transforming a spreadsheet of metadata and folder of images into a digital exhibition website. Visit the documentation to view examples.\n  Hugo Hugo is a newer static site generator. It was designed for scale and flexibility in order to support any type of website. It is written in the Go programming language, but \u0026ndash;like Jekyll\u0026ndash; programming knowledge or experience is not necessary unless you need to modify or develop themes or templates. Hugo is known for its speed. Static websites are usually built entirely at once, where as dynamic websites can build pages as needed. When you\u0026rsquo;re working with large static sites, the build time can minutes, which can slow down the development process. Hugo is able to build a website with thousands of pages in seconds \u0026ndash; if not milliseconds \u0026ndash; while another static site generator might take minutes. I recommend Hugo because it\u0026rsquo;s easy to install and works with a lot of themes.\n  Quire is a multiformat book publishing tool by the Getty. It uses Hugo as an underlying static site generator for building the web versions of academic books and museum catalogs. Quire also makes EPUB, PDF, and Mobi/Kindle files as output formats for the books from Markdown and YAML content. Here\u0026rsquo;s a list of books made with Quire.\n  Blogdown is a method of making static websites that contain reproducible data analysis, tables, figures, graphics, and other forms of scientific content generated with the R programming language. This can be an especially useful \u0026ndash;and perhaps familiar\u0026ndash; option for anyone using R for statistical computing in the sciences and social sciences. Like Quire, Blogdown uses Hugo as an underlying software program for generating the static website files.\n  Wowchemy is an open source suite of Hugo website themes and features for educational, personal, and group websites. They provide a variety of templates and guides for new users.\n  Recommendations for Math Static websites can render mathematical equations in the web browser using MathJax. MathJax can be added to any website by adding a line or two to the \u0026lt;head\u0026gt; element in the HTML template (see: instructions). MathJax is a popular feature included in themes for static site generators focused on academic or technical content. For more specialized cases, these open source projects produce static websites for mathematical content.\n Bookdown, like Blogdown, was developed for users of the R programming language. Unlike Blogdown, Bookdown does not use Hugo for statis site generation, but it does generate static files for website, PDF, EPUB, LaTeX, and Microsoft Word versions of books. This is a popular tool for books on statistics, data science, and R programming.  The following projects do not use Markdown as an input format.\n  LaTeXML is a LaTeX to HTML converter. This was used to create the Digital Library of Mathematical Functions of the National Institute of Standards and Technology. This is a great recommendation for scholars who prefer wrtiting in LaTeX or TeX than Markdown. Given that, it relies on a lot more software to process mathematics, TeX environments, macros, and PostScript graphics than a modern static site generator.\n  PreTeXt is an XML scheme for research articles, textbooks, and monographs. PreTeXt can create websites, PDFs, EPUB, and Jupyter Notebook documents from XML using XLST. It\u0026rsquo;s currently used to make open mathematics textbooks.\n  Open Infrastructure for Scholarly Communications Learning Objective: After examining this topic, participants will be able to identify challenges and take action toward developing and sustaining an open infrastructure for scholarly communications.  The acquisitions of the Social Science Research Network (SSRN) and bepress by Elsevier revealed a \u0026ldquo;need for community-based scholarly communication infrastructure\u0026rdquo; by many within the academic library community. SSRN is preprint repository for social sciences and humanities research. Bepress began as an open access, academic journal publishing platform provider and eventually expanded its product list to include a hosted institutional repository platform. Both SSRN and bepress provide scholars with open access alternatives to exlusively publishing their work in subscription-access journals. Hundreds of academic libraries around the world subscribed to bepress products to support their scholarly communications iniatives. For academic library customers, the news of the bepress acquisition in particular meant that their primary vehicle for open access publishing was now owned by one of the largest commercial scientific journal publishers in the world.\nThis led to the \u0026ldquo;2.5% Commitment,\u0026rdquo; a famous call to action by David W. Lewis, Dean of the IUPUI University Library at the time. In it, Lewis urges libraries to contribute 2.5% of its total budget to \u0026ldquo;support the common infrastructure needed to create the open scholarly commons\u0026hellip; Collectively we would take responsibility for curating and preserving the world’s scientific, scholarly, and cultural heritage thus making it discoverable and freely available to everyone in the world now and in the future\u0026rdquo; Lewis, 2017. Open source software is a key example of the types of contributions academic libraries can make toward this goal.\nReadings:\n  “Elsevier Acquisition Highlights the Need for Community-Based Scholarly Communication Infrastructure.” 2017. SPARC. September 6, 2017.\n  Lewis, David W. 2017. “The 2.5% Commitment.” Working Paper. https://doi.org/10.7912/C2JD29.\n  Skinner, Katherine. July 23, 2019. “Why Are So Many Scholarly Communication Infrastructure Providers Running a Red Queen’s Race?.\u0026quot; Educopia Institute.\n  Discussion Questions:\n Are static website technologies examples of open infrastructure for scholarly communication? In what ways do static websites address or complicate the impediments to sustaining scholarly communication resources Skinner (2019) outlines?   Community Engagement There are several vibrant communities working in library, cultural heritage, and scholarly communication technologies who share the values of community-driven, open infrastructure. Here are a few for scholarly communications and digital scholarship librarians to begin following and contributing to this work:\n  Invest in Open Infrastructure is \u0026ldquo;is an initiative dedicated to improving funding and resourcing for open technologies and systems supporting research and scholarship.\u0026rdquo;\n  Code4Lib is a volunteer network of people working in \u0026ndash;or adjacent to\u0026ndash; library technology.\n  Library Publishing Coalition is \u0026ldquo;an independent, community-led membership association of academic and research libraries and library consortia engaged in scholarly publishing.\u0026rdquo;\n  "});index.add({'id':5,'href':'/static-web-scholcomm/teaching-resources/bibliography/','title':"Bibliography",'content':"This annotated bibliography provides an overview of how static websites can be used for scholarly purposes. It includes publications representing a variety of communities, including libraries, digital humanities, and open source software. The citations included in this bibliography \u0026ndash;with few exceptions\u0026ndash; focus on librarians and scholars who use static websites for their work.\n Download PDF   Download DOCX    Articles Tutorials Podcasts   Articles Becker, Devin, Evan Williamson, and Olivia Wikle. 2020. “CollectionBuilder-CONTENTdm: Developing a Static Web ‘Skin’ for CONTENTdm-Based Digital Collections.” The Code4Lib Journal, no. 49 (August).\n Becker et al. introduce a workflow and toolset for developing custom static websites for collections in the University of Idaho Library\u0026rsquo;s CONTENTdm digital asset management system. They do this in order to supplement the public-facing features of their collection management system with a friendlier user-interface and \u0026ldquo;collections as data\u0026rdquo; export features. This article also includes a brilliant overview of their Git/GitHub-based workflow. This real-world example of using static websites to supplement repository systems resembles the scenario in the \u0026ldquo;Introduction to Static Site Generators\u0026rdquo; tutorial.   Diaz, Chris. 2018. “Using Static Site Generators for Scholarly Publications and Open Educational Resources.” The Code4Lib Journal, no. 42 (November).\n This article reports on experiences using Jekyll and Bookdown for library publishing projects at Northwestern University. The Jekyll site was made for a conference proceedings publication; the Bookdown site was for an open statistics textbook.   Gil, Alex, and Kaiama L. Glover. 2016. “The Sx:Archipelagos Project,” Humanitites Commons.\n This paper reports on the planning and execution of a new platform for publishing peer-reviewed scholarship using minimal computing principles. The platform uses technologies that minimize the social/labor costs of scholarly publihsing, namely plain text (Markdown) and static site generators (Jekyll). The result can be seen in archipelagos: a journal of Caribbean digital praxis and replicated with their workflow.   Gil, Alex. 2015. “The User, the Learner and the Machines We Make · Minimal Computing.” Minimal Computing: A Working Group of GO::DH. May 21, 2015.\n This is the canonical essay on minimal computing in digital humanities. Minimal computing centers around the question, \u0026ldquo;what do we need?\u0026rdquo; Scholarly communications librarians need resources for publishing academic texts online in order to be discovered and accessed by the public without restrictions. This can be accomplished with an open source static site generator, basic web hosting, and minimal maintenance costs. Importantly, the essay asks us to \u0026ldquo;displace [our] reliance on \u0026lsquo;user friendly\u0026rsquo; mechanisms,\u0026rdquo; like content management systems and hosted platforms, for smaller technical infrastructures, like plain text and static websites, that are cheaper to sustain and easier to preserve.   Lewis, David W., Lori Goetsch, Diane Graves, and Mike Roy. 2018. “Funding Community Controlled Open Infrastructure for Scholarly Communication: The 2.5% Commitment Initiative\u0026quot; College \u0026amp; Research Libraries News.\n Personally, this call for community action toward sustainable open infrastructure for scholarly commmunication motivated me to think about static web technologies as microinfrastructures for an open scholarly commons that individual librarians can build with little more than personal computers.   Newson, Kaitlin. 2017. “Tools and Workflows for Collaborating on Static Website Projects.” The Code4Lib Journal, no. 38 (October).\n Newson introduces static site generators for digital library projects with a case study involving a digitized maps collection. Newsom explains how static site generators work and discusses their advantages and disadvantages for team projects.   Seo, Joo Young, and Sean McCurry. 2019. “LaTeX Is NOT Easy: Creating Accessible Scientific Documents with R Markdown.” Journal on Technology and Persons with Disabilities 7 (16).\n Seo and McCurry study the accessibility of authoring tools for scientific documents (i.e. documents that require math formulas, embedded graphics, figures, and bibiliographic citations) and introduce the Accessible RMarkdown Online Writer, a web-based authoring tool for blind and low-vision writers of scientific content. They argue that plain text formats make authoring scientific information more accessible to blind and low vision people. However, the predominate plain text format for scientific writing, LaTeX, has a steep learning curve and one output format: PDF. Markdown, on the other hand, is a semantically rich plain text format with a simpler syntax, support for LaTeX math, and wider range of output formats: HTML, PDF, Microsoft Word, RTF, EPUB, PowerPoint, etc.   Varner, Stewart. 2017. “Minimal Computing in Libraries: Introduction · Minimal Computing.” Minimal Computing: A Working Group of GO::DH. 2017.\n Varner unpacks the hidden costs and labor involved in managing web services in order to make a case for minimal computing approaches, including but not limited to static websites.   Tutorials “Fundamentals: YAML \u0026amp; Markdown.” 2020. In Quire: Multiformat Book Publishing. J. Paul Getty Trust, Los Angeles.\n This is a chapter from the manual for Quire, a multiformat book publishing framework, but it is an excellent introduction to the fundamentals of Markdown and YAML in the context of a static site generator for book publishing. The concepts covered in the chapter are essential to using any static site generator. There\u0026rsquo;s also some important guiance on converting documents from Microsoft Word to plain text.   Simpkin, Sarah. 2015. “Getting Started with Markdown.” Programming Historian.\n This tutorial \u0026ndash;written for humanities scholars\u0026ndash; is a web-based introduction to the Markdown syntax. Markdown is a fundamental content format for static site generators and is applicable in a variety of scholarly contexts, as explained by Tenen \u0026amp; Wythoff, 2014.   Tenen, Dennis, and Grant Wythoff. 2014. “Sustainable Authorship in Plain Text Using Pandoc and Markdown.” Programming Historian.\n This tutorial and essay is a deep-dive into plain text for scholarly writing. The essays makes a case for the use of plain text formats for scholarly writing, distribution, and preservation. The tutorial, in addition to teaching the fundamentals of markdown syntax, covers the basic use of Pandoc, an open source command-line tool for converting documents between formats. Pandoc is an essential tool for digital publishing production and basic web development.   P2PU. 2020. “Course-in-a-Box: An open-source project for creating online courses.”\n Course-in-a-Box is a tutorial and instructional guide for creating free course websites on GitHub. The tutorial teaches you to use Markdown and YAMl in the GitHub web interface to create and publishing a static website. No installation of software is required, but everything covered in the instructions is applicable for using static site generators (specifically Jekyll).  Visconti, Amanda. 2016. “Building a Static Website with Jekyll and GitHub Pages.” Programming Historian.\n Visconti provides a guided lesson on using the Jekyll static site generator and GitHub for creating an entirely free, easy-to-maintain, preservation-friendly, secure website over which you have full control, such as a scholarly blog, project website, or online portfolio.\u0026quot; The section on \u0026ldquo;What are static sites, Jekyll, etc. \u0026amp; why might I care?\u0026rdquo; is an excellent introduction. Jekyll, like Hugo, is an excellent static site generator for digital scholarship use cases.   Williamson, Evan. 2019. “Web Crash Course! An Intro to Basic Web Concepts Using GitHub and GitHub Pages.” Web-Crash-Course. 2019.\n This is an excellent practical introduction to web technologies. It covers the basic tools and concepts people need to begin working with websites in any context, including text editors, HTML, CSS, and JavaScript. Most of the readings and content on static site generators assume some knowledge of HTML, CSS, and JavaScript. If you\u0026rsquo;re at all unclear about the functions HTML, CSS, and JavaScript in creating websites, I highly recommend this web course.   Williamson, Evan. 2020. “Introduction to Creating Websites with GitHub Pages and Jekyll.” Go-Go Gh-Pages!\n This is an excellent introduction to using GitHub for static site publishing. From the website: \u0026ldquo;This workshop will introduce using free hosting from GitHub Pages integrated with the popular static website generator Jekyll. Along the way we will cover the basics of GitHub, HTML, Markdown, and Jekyll. You will learn how to set up a project repository, write content in Markdown, and publish your site, all using GitHub’s user friendly web interface. More advanced usage of Jekyll for local web development is introduced final section.\u0026rdquo; Follow along with the videos for the full workshop experience.   Williamson, Evan. 2018. “OER on GitHub What, Why, \u0026amp; How.” Make OER!\n This workshop covers the basics of using GitHub for Open Educational Resources (OER). The materials include examples of OER on GitHub, information about textbook costs and the value proposition of OER, and resources for learning.   Podcasts Abdalla, Safia, Kevin Ball, and Christopher Hiller. 2019. “Our Thoughts and Experiences with SSGs (JS Party #59).” Changelog.\n JS Party is a JavaScript focused podcast. In this episode, the hosts define static site generators in terms of how they fit in the history of the web and modern web development. During the first 20 minutes, they walk through the process of evaluating the usefulness of a static site generator for a project. For example, how often does the site\u0026rsquo;s content change? What workflows and permissions do you need to support for content updates? What do the users of the site need to be able to do? The rest of the episode includes personal experiences using static site generators in professional contexts and musings about the future of static site generators for web developers.   Nantz, Eric, and Xie Yihui. 400AD. “Episode 24: Yihui Xie Returns (Rstudio::Conf 2018).” The R-Podcast.\n This podcast includes interviews and advice on using the R programming language for statistical computing. This episode features an interview with Yihui Xie, the inventor of several popular R packages, among them: Blogdown and Bookdown. Both of these packages create static websites from R Markdown, which is a version of Markdown that can execute R code while exporting to various formats, including PDF and HTML formats. Blogdown and Bookdown, as the names suggest, help with making blogs (actually, any kind of website) and books. The Bookdown package, in particular, is an excellent package for building OER textbooks and scholarly monographs because it supports bibiliographic references, math formatting, and several output formats: websites, PDFs, EPUB, and Microsoft Word documents. Xie discusses the motivations for creating packages that help streamline the process for writing and publishing reproducible research documents. He also touches on the benefits of markdown for writers: forces writers to focus on the content (rather than the style) and for portability to multiple systems. The second half of the interview focuses on process for developing the packages and his perspective of being an author of open access books.   Price Lab for Digital Humanities. 2020. \u0026ldquo;Dream Lab Podcast • Episode 5 • Alex Gil • Minimal Computing\u0026rdquo;.\n Price Lab for Digital Humanities at the University of Pennsylvania interviews Alex Gil of Columbia University Libraries about minimal computing. Minimal computing is a mode of creating digital scholarship under intentional contraints of hardware and software in order to facilitate long-term access to scholarly artifacts. The conversation features Wax, which is a methodology and framework for creating a static website for primary source images online. Using the example of Wax for digital exhibits, Gil discusses the challenges traditional digital exhibit platforms produce for libraries in maintaining them for longevity.   Tolinski, Scott, and Wes Bos. n.d. Why Static Site Generators Are Awesome — Syntax Podcast 034. Accessed November 12, 2020. .\n Skip to minute 8:00 for an introduction to static site generators and why they are attractive to front-end web developers. The hosts are primarily JavaScript developers, so they go into a lot of advanced use cases for static site generators in more business-oriented contexts, but they do a good job covering the key concepts of the technology. This conversation includes talking points that could be especially useful for building a case with your technology managers and IT departments for use static site generators for library-supported digital projects.  "});index.add({'id':6,'href':'/static-web-scholcomm/categories/','title':"Categories",'content':""});index.add({'id':7,'href':'/static-web-scholcomm/','title':"Resources for Scholarly Communications Librarians",'content':"Websites for scholarly publications and digital scholarship are expected to be stable for long-term access, citation, and archiving. Static websites provide a durable and low-cost solution for making and distributing scholarly works.\nIn library and academic contexts, static websites have been used for conference websites, digitization projects, archival metadata, academic journals, edited monographs, and open textbooks.\nThese resources introduce this powerful technology for scholarly communications librarianship.\nContents  A lesson plan for learning about static web publishing for digital scholarship projects. An annotated bibliography of articles, tutorials, and podcasts about static websites in academic contexts. A quick demonstration of GitHub as a static website hosting platform An introduction to static site generators tutorial  Credits This resource was created by Chris Diaz, Digital Publishing Librarian at Northwestern University. As part of the Scholarly Communication Notebook, this work was generously supported by the Institute of Museum and Library Services LG-36-19-0021-19. Unless otherwise noted, these materials are licensed under Creative Commons Attribution (CC BY) 4.0 International license.\nView Source Files   Feedback Thank you for visiting this resource. If you have any questions or suggestions about this website, please email me or open an issue.\n"});index.add({'id':8,'href':'/static-web-scholcomm/tags/','title':"Tags",'content':""});})();